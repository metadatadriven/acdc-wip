/******************************************************************************
 * This file was generated by langium-cli 3.5.2.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import * as langium from 'langium';

export const ThunderstruckTerminals = {
    NUMBER: /[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?/,
    ID: /[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
    WS: /\s+/,
};

export type ThunderstruckTerminalNames = keyof typeof ThunderstruckTerminals;

export type ThunderstruckKeywordNames =
    | "!="
    | "("
    | ")"
    | "*"
    | "+"
    | ","
    | "-"
    | "."
    | "/"
    | ":"
    | ";"
    | "<"
    | "<="
    | "="
    | "=="
    | ">"
    | ">="
    | "Binomial"
    | "CodedValue"
    | "Date"
    | "DateTime"
    | "Flag"
    | "Gamma"
    | "Gaussian"
    | "Identifier"
    | "Identity"
    | "Integer"
    | "Inverse"
    | "InverseGaussian"
    | "Log"
    | "Logit"
    | "Numeric"
    | "Poisson"
    | "Probit"
    | "Sqrt"
    | "Text"
    | "["
    | "]"
    | "^"
    | "aesthetics"
    | "aggregate"
    | "and"
    | "as"
    | "attributes"
    | "category"
    | "ci_lower"
    | "ci_upper"
    | "codeLists"
    | "columns"
    | "concept"
    | "count"
    | "cube"
    | "definition"
    | "derivations"
    | "derive"
    | "dimensions"
    | "display"
    | "false"
    | "family"
    | "figure"
    | "fix"
    | "footnotes"
    | "format"
    | "formula"
    | "from"
    | "groupBy"
    | "import"
    | "input"
    | "is_a"
    | "link"
    | "max"
    | "mean"
    | "measures"
    | "median"
    | "min"
    | "model"
    | "namespace"
    | "not"
    | "or"
    | "output"
    | "properties"
    | "property"
    | "quantile"
    | "random"
    | "rows"
    | "slice"
    | "source"
    | "standards"
    | "statistics"
    | "stddev"
    | "structure"
    | "subject"
    | "sum"
    | "table"
    | "true"
    | "type_of"
    | "unit"
    | "variance"
    | "vary"
    | "where"
    | "xAxis"
    | "yAxis"
    | "{"
    | "|"
    | "}"
    | "~";

export type ThunderstruckTokenNames = ThunderstruckTerminalNames | ThunderstruckKeywordNames;

export type AggregateFunction = 'ci_lower' | 'ci_upper' | 'count' | 'max' | 'mean' | 'median' | 'min' | 'quantile' | 'stddev' | 'sum' | 'variance';

export function isAggregateFunction(item: unknown): item is AggregateFunction {
    return item === 'mean' || item === 'median' || item === 'stddev' || item === 'variance' || item === 'min' || item === 'max' || item === 'count' || item === 'sum' || item === 'quantile' || item === 'ci_lower' || item === 'ci_upper';
}

export type DisplayType = 'figure' | 'table';

export function isDisplayType(item: unknown): item is DisplayType {
    return item === 'table' || item === 'figure';
}

export type Expression = BinaryExpression | FunctionCallExpression | Literal | MemberAccessExpression | UnaryExpression | VariableReference;

export const Expression = 'Expression';

export function isExpression(item: unknown): item is Expression {
    return reflection.isInstance(item, Expression);
}

export type FormulaTerm = FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaNumber | FormulaPower | FormulaVariable;

export const FormulaTerm = 'FormulaTerm';

export function isFormulaTerm(item: unknown): item is FormulaTerm {
    return reflection.isInstance(item, FormulaTerm);
}

export type LinkFunction = 'Identity' | 'Inverse' | 'Log' | 'Logit' | 'Probit' | 'Sqrt';

export function isLinkFunction(item: unknown): item is LinkFunction {
    return item === 'Identity' || item === 'Log' || item === 'Logit' || item === 'Probit' || item === 'Inverse' || item === 'Sqrt';
}

export type Literal = BooleanLiteral | NumberLiteral | StringLiteral;

export const Literal = 'Literal';

export function isLiteral(item: unknown): item is Literal {
    return reflection.isInstance(item, Literal);
}

export type ModelFamily = 'Binomial' | 'Gamma' | 'Gaussian' | 'InverseGaussian' | 'Poisson';

export function isModelFamily(item: unknown): item is ModelFamily {
    return item === 'Gaussian' || item === 'Binomial' || item === 'Poisson' || item === 'Gamma' || item === 'InverseGaussian';
}

export type OutputCubeSpec = CubeDefinition | OutputCubeRef;

export const OutputCubeSpec = 'OutputCubeSpec';

export function isOutputCubeSpec(item: unknown): item is OutputCubeSpec {
    return reflection.isInstance(item, OutputCubeSpec);
}

export type ProgramElement = AggregateDefinition | ConceptDefinition | CubeDefinition | DeriveDefinition | DisplayDefinition | ImportStatement | ModelDefinition | SliceDefinition | StandardsDeclaration;

export const ProgramElement = 'ProgramElement';

export function isProgramElement(item: unknown): item is ProgramElement {
    return reflection.isInstance(item, ProgramElement);
}

export type TypeReference = CodedValueType | IdentifierType | PrimitiveType;

export const TypeReference = 'TypeReference';

export function isTypeReference(item: unknown): item is TypeReference {
    return reflection.isInstance(item, TypeReference);
}

export interface AestheticOption extends langium.AstNode {
    readonly $container: AestheticSpec;
    readonly $type: 'AestheticOption';
    key: string;
    value: string;
}

export const AestheticOption = 'AestheticOption';

export function isAestheticOption(item: unknown): item is AestheticOption {
    return reflection.isInstance(item, AestheticOption);
}

export interface AestheticSpec extends langium.AstNode {
    readonly $container: FigureSpec;
    readonly $type: 'AestheticSpec';
    options: Array<AestheticOption>;
}

export const AestheticSpec = 'AestheticSpec';

export function isAestheticSpec(item: unknown): item is AestheticSpec {
    return reflection.isInstance(item, AestheticSpec);
}

export interface AggregateDefinition extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'AggregateDefinition';
    description?: string;
    groupBy: DimensionList;
    inputRef: langium.Reference<ProgramElement>;
    name: string;
    output?: OutputCubeSpec;
    statistics: StatisticList;
}

export const AggregateDefinition = 'AggregateDefinition';

export function isAggregateDefinition(item: unknown): item is AggregateDefinition {
    return reflection.isInstance(item, AggregateDefinition);
}

export interface BinaryExpression extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'BinaryExpression';
    left: Expression;
    operator: '!=' | '*' | '+' | '-' | '/' | '<' | '<=' | '==' | '>' | '>=' | 'and' | 'or';
    right: Expression;
}

export const BinaryExpression = 'BinaryExpression';

export function isBinaryExpression(item: unknown): item is BinaryExpression {
    return reflection.isInstance(item, BinaryExpression);
}

export interface BooleanLiteral extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'BooleanLiteral';
    value: 'false' | 'true';
}

export const BooleanLiteral = 'BooleanLiteral';

export function isBooleanLiteral(item: unknown): item is BooleanLiteral {
    return reflection.isInstance(item, BooleanLiteral);
}

export interface CodedValueType extends langium.AstNode {
    readonly $container: Component;
    readonly $type: 'CodedValueType';
    codeList?: CodeListRef;
}

export const CodedValueType = 'CodedValueType';

export function isCodedValueType(item: unknown): item is CodedValueType {
    return reflection.isInstance(item, CodedValueType);
}

export interface CodeListMapping extends langium.AstNode {
    readonly $container: CodeListMappings;
    readonly $type: 'CodeListMapping';
    code: string;
    namespace: CodeListNamespace;
}

export const CodeListMapping = 'CodeListMapping';

export function isCodeListMapping(item: unknown): item is CodeListMapping {
    return reflection.isInstance(item, CodeListMapping);
}

export interface CodeListMappings extends langium.AstNode {
    readonly $container: ConceptDefinition;
    readonly $type: 'CodeListMappings';
    mappings: Array<CodeListMapping>;
}

export const CodeListMappings = 'CodeListMappings';

export function isCodeListMappings(item: unknown): item is CodeListMappings {
    return reflection.isInstance(item, CodeListMappings);
}

export interface CodeListNamespace extends langium.AstNode {
    readonly $container: CodeListMapping;
    readonly $type: 'CodeListNamespace';
    segments: Array<string>;
}

export const CodeListNamespace = 'CodeListNamespace';

export function isCodeListNamespace(item: unknown): item is CodeListNamespace {
    return reflection.isInstance(item, CodeListNamespace);
}

export interface CodeListRef extends langium.AstNode {
    readonly $container: CodedValueType;
    readonly $type: 'CodeListRef';
    segments: Array<string>;
}

export const CodeListRef = 'CodeListRef';

export function isCodeListRef(item: unknown): item is CodeListRef {
    return reflection.isInstance(item, CodeListRef);
}

export interface ColumnFormat extends langium.AstNode {
    readonly $container: FormatSpec;
    readonly $type: 'ColumnFormat';
    column: string;
    options: Array<FormatOption>;
}

export const ColumnFormat = 'ColumnFormat';

export function isColumnFormat(item: unknown): item is ColumnFormat {
    return reflection.isInstance(item, ColumnFormat);
}

export interface Component extends langium.AstNode {
    readonly $container: ComponentList;
    readonly $type: 'Component';
    concept?: langium.Reference<ConceptDefinition>;
    name: string;
    type: TypeReference;
}

export const Component = 'Component';

export function isComponent(item: unknown): item is Component {
    return reflection.isInstance(item, Component);
}

export interface ComponentList extends langium.AstNode {
    readonly $container: CubeStructure;
    readonly $type: 'ComponentList';
    components: Array<Component>;
}

export const ComponentList = 'ComponentList';

export function isComponentList(item: unknown): item is ComponentList {
    return reflection.isInstance(item, ComponentList);
}

export interface ConceptDefinition extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'ConceptDefinition';
    category?: string;
    codeLists?: CodeListMappings;
    definition?: string;
    description?: string;
    name: string;
    parentType?: langium.Reference<ConceptDefinition>;
    properties?: ConceptPropertyList;
    unit?: string;
}

export const ConceptDefinition = 'ConceptDefinition';

export function isConceptDefinition(item: unknown): item is ConceptDefinition {
    return reflection.isInstance(item, ConceptDefinition);
}

export interface ConceptProperty extends langium.AstNode {
    readonly $container: ConceptPropertyList;
    readonly $type: 'ConceptProperty';
    name: string;
    type: langium.Reference<ConceptDefinition>;
}

export const ConceptProperty = 'ConceptProperty';

export function isConceptProperty(item: unknown): item is ConceptProperty {
    return reflection.isInstance(item, ConceptProperty);
}

export interface ConceptPropertyList extends langium.AstNode {
    readonly $container: ConceptDefinition;
    readonly $type: 'ConceptPropertyList';
    properties: Array<ConceptProperty>;
}

export const ConceptPropertyList = 'ConceptPropertyList';

export function isConceptPropertyList(item: unknown): item is ConceptPropertyList {
    return reflection.isInstance(item, ConceptPropertyList);
}

export interface CovarianceStructure extends langium.AstNode {
    readonly $container: RandomEffects;
    readonly $type: 'CovarianceStructure';
    parameter?: string;
    structureType: string;
}

export const CovarianceStructure = 'CovarianceStructure';

export function isCovarianceStructure(item: unknown): item is CovarianceStructure {
    return reflection.isInstance(item, CovarianceStructure);
}

export interface CubeDefinition extends langium.AstNode {
    readonly $container: AggregateDefinition | DeriveDefinition | ModelDefinition | Program;
    readonly $type: 'CubeDefinition';
    description?: string;
    name: string;
    namespace?: string;
    structure: CubeStructure;
}

export const CubeDefinition = 'CubeDefinition';

export function isCubeDefinition(item: unknown): item is CubeDefinition {
    return reflection.isInstance(item, CubeDefinition);
}

export interface CubeStructure extends langium.AstNode {
    readonly $container: CubeDefinition;
    readonly $type: 'CubeStructure';
    attributes?: ComponentList;
    dimensions?: ComponentList;
    measures?: ComponentList;
}

export const CubeStructure = 'CubeStructure';

export function isCubeStructure(item: unknown): item is CubeStructure {
    return reflection.isInstance(item, CubeStructure);
}

export interface Derivation extends langium.AstNode {
    readonly $container: DerivationList;
    readonly $type: 'Derivation';
    expression: Expression;
    target: string;
}

export const Derivation = 'Derivation';

export function isDerivation(item: unknown): item is Derivation {
    return reflection.isInstance(item, Derivation);
}

export interface DerivationList extends langium.AstNode {
    readonly $container: DeriveDefinition;
    readonly $type: 'DerivationList';
    derivations: Array<Derivation>;
}

export const DerivationList = 'DerivationList';

export function isDerivationList(item: unknown): item is DerivationList {
    return reflection.isInstance(item, DerivationList);
}

export interface DeriveDefinition extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'DeriveDefinition';
    derivations?: DerivationList;
    description?: string;
    inputRef: langium.Reference<ProgramElement>;
    name: string;
    output: OutputCubeSpec;
}

export const DeriveDefinition = 'DeriveDefinition';

export function isDeriveDefinition(item: unknown): item is DeriveDefinition {
    return reflection.isInstance(item, DeriveDefinition);
}

export interface DimensionConstraint extends langium.AstNode {
    readonly $container: DimensionConstraints;
    readonly $type: 'DimensionConstraint';
    dimension: string;
    value: Expression;
}

export const DimensionConstraint = 'DimensionConstraint';

export function isDimensionConstraint(item: unknown): item is DimensionConstraint {
    return reflection.isInstance(item, DimensionConstraint);
}

export interface DimensionConstraints extends langium.AstNode {
    readonly $container: SliceDefinition;
    readonly $type: 'DimensionConstraints';
    constraints: Array<DimensionConstraint>;
}

export const DimensionConstraints = 'DimensionConstraints';

export function isDimensionConstraints(item: unknown): item is DimensionConstraints {
    return reflection.isInstance(item, DimensionConstraints);
}

export interface DimensionList extends langium.AstNode {
    readonly $container: AggregateDefinition | SliceDefinition | TableSpec;
    readonly $type: 'DimensionList';
    dimensions: Array<string>;
}

export const DimensionList = 'DimensionList';

export function isDimensionList(item: unknown): item is DimensionList {
    return reflection.isInstance(item, DimensionList);
}

export interface DisplayDefinition extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'DisplayDefinition';
    description?: string;
    displayType: DisplayType;
    figureSpec?: FigureSpec;
    footnotes?: FootnoteList;
    sourceRef: langium.Reference<ProgramElement>;
    tableSpec?: TableSpec;
    title?: string;
}

export const DisplayDefinition = 'DisplayDefinition';

export function isDisplayDefinition(item: unknown): item is DisplayDefinition {
    return reflection.isInstance(item, DisplayDefinition);
}

export interface FigureSpec extends langium.AstNode {
    readonly $container: DisplayDefinition;
    readonly $type: 'FigureSpec';
    aesthetics?: AestheticSpec;
    groupBy?: string;
    xAxis?: string;
    yAxis?: string;
}

export const FigureSpec = 'FigureSpec';

export function isFigureSpec(item: unknown): item is FigureSpec {
    return reflection.isInstance(item, FigureSpec);
}

export interface FootnoteList extends langium.AstNode {
    readonly $container: DisplayDefinition;
    readonly $type: 'FootnoteList';
    footnotes: Array<string>;
}

export const FootnoteList = 'FootnoteList';

export function isFootnoteList(item: unknown): item is FootnoteList {
    return reflection.isInstance(item, FootnoteList);
}

export interface FormatOption extends langium.AstNode {
    readonly $container: ColumnFormat;
    readonly $type: 'FormatOption';
    key: string;
    value: number | string;
}

export const FormatOption = 'FormatOption';

export function isFormatOption(item: unknown): item is FormatOption {
    return reflection.isInstance(item, FormatOption);
}

export interface FormatSpec extends langium.AstNode {
    readonly $container: TableSpec;
    readonly $type: 'FormatSpec';
    formats: Array<ColumnFormat>;
}

export const FormatSpec = 'FormatSpec';

export function isFormatSpec(item: unknown): item is FormatSpec {
    return reflection.isInstance(item, FormatSpec);
}

export interface Formula extends langium.AstNode {
    readonly $container: ModelDefinition;
    readonly $type: 'Formula';
    predictors: FormulaTerm;
    response: FormulaTerm;
}

export const Formula = 'Formula';

export function isFormula(item: unknown): item is Formula {
    return reflection.isInstance(item, Formula);
}

export interface FormulaAddition extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaAddition';
    left: FormulaTerm;
    operator: '+' | '-';
    right: FormulaTerm;
}

export const FormulaAddition = 'FormulaAddition';

export function isFormulaAddition(item: unknown): item is FormulaAddition {
    return reflection.isInstance(item, FormulaAddition);
}

export interface FormulaConditioning extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaConditioning';
    left: FormulaTerm;
    operator: '|';
    right: FormulaTerm;
}

export const FormulaConditioning = 'FormulaConditioning';

export function isFormulaConditioning(item: unknown): item is FormulaConditioning {
    return reflection.isInstance(item, FormulaConditioning);
}

export interface FormulaCrossing extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaCrossing';
    left: FormulaTerm;
    operator: '*';
    right: FormulaTerm;
}

export const FormulaCrossing = 'FormulaCrossing';

export function isFormulaCrossing(item: unknown): item is FormulaCrossing {
    return reflection.isInstance(item, FormulaCrossing);
}

export interface FormulaFunction extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaFunction';
    arguments: Array<FormulaTerm>;
    function: string;
}

export const FormulaFunction = 'FormulaFunction';

export function isFormulaFunction(item: unknown): item is FormulaFunction {
    return reflection.isInstance(item, FormulaFunction);
}

export interface FormulaInteraction extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaInteraction';
    left: FormulaTerm;
    operator: ':';
    right: FormulaTerm;
}

export const FormulaInteraction = 'FormulaInteraction';

export function isFormulaInteraction(item: unknown): item is FormulaInteraction {
    return reflection.isInstance(item, FormulaInteraction);
}

export interface FormulaNesting extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaNesting';
    left: FormulaTerm;
    operator: '/';
    right: FormulaTerm;
}

export const FormulaNesting = 'FormulaNesting';

export function isFormulaNesting(item: unknown): item is FormulaNesting {
    return reflection.isInstance(item, FormulaNesting);
}

export interface FormulaNumber extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaNumber';
    value: number;
}

export const FormulaNumber = 'FormulaNumber';

export function isFormulaNumber(item: unknown): item is FormulaNumber {
    return reflection.isInstance(item, FormulaNumber);
}

export interface FormulaPower extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaPower';
    left: FormulaTerm;
    operator: '^';
    right: FormulaTerm;
}

export const FormulaPower = 'FormulaPower';

export function isFormulaPower(item: unknown): item is FormulaPower {
    return reflection.isInstance(item, FormulaPower);
}

export interface FormulaVariable extends langium.AstNode {
    readonly $container: Formula | FormulaAddition | FormulaConditioning | FormulaCrossing | FormulaFunction | FormulaInteraction | FormulaNesting | FormulaPower;
    readonly $type: 'FormulaVariable';
    variable: string;
}

export const FormulaVariable = 'FormulaVariable';

export function isFormulaVariable(item: unknown): item is FormulaVariable {
    return reflection.isInstance(item, FormulaVariable);
}

export interface FunctionCallExpression extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'FunctionCallExpression';
    arguments: Array<Expression>;
    function: string;
}

export const FunctionCallExpression = 'FunctionCallExpression';

export function isFunctionCallExpression(item: unknown): item is FunctionCallExpression {
    return reflection.isInstance(item, FunctionCallExpression);
}

export interface IdentifierType extends langium.AstNode {
    readonly $container: Component;
    readonly $type: 'IdentifierType';
    type: 'Identifier';
}

export const IdentifierType = 'IdentifierType';

export function isIdentifierType(item: unknown): item is IdentifierType {
    return reflection.isInstance(item, IdentifierType);
}

export interface ImportPath extends langium.AstNode {
    readonly $container: ImportStatement;
    readonly $type: 'ImportPath';
    segments: Array<string>;
}

export const ImportPath = 'ImportPath';

export function isImportPath(item: unknown): item is ImportPath {
    return reflection.isInstance(item, ImportPath);
}

export interface ImportStatement extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'ImportStatement';
    alias?: string;
    importPath: ImportPath;
}

export const ImportStatement = 'ImportStatement';

export function isImportStatement(item: unknown): item is ImportStatement {
    return reflection.isInstance(item, ImportStatement);
}

export interface MeasureList extends langium.AstNode {
    readonly $container: SliceDefinition;
    readonly $type: 'MeasureList';
    measures: Array<string>;
}

export const MeasureList = 'MeasureList';

export function isMeasureList(item: unknown): item is MeasureList {
    return reflection.isInstance(item, MeasureList);
}

export interface MemberAccessExpression extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'MemberAccessExpression';
    member: string;
    receiver: Expression;
}

export const MemberAccessExpression = 'MemberAccessExpression';

export function isMemberAccessExpression(item: unknown): item is MemberAccessExpression {
    return reflection.isInstance(item, MemberAccessExpression);
}

export interface ModelDefinition extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'ModelDefinition';
    description?: string;
    family?: ModelFamily;
    formula: Formula;
    inputRef: langium.Reference<ProgramElement>;
    link?: LinkFunction;
    name: string;
    output?: OutputCubeSpec;
    randomEffects?: RandomEffects;
}

export const ModelDefinition = 'ModelDefinition';

export function isModelDefinition(item: unknown): item is ModelDefinition {
    return reflection.isInstance(item, ModelDefinition);
}

export interface NumberLiteral extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'NumberLiteral';
    value: number;
}

export const NumberLiteral = 'NumberLiteral';

export function isNumberLiteral(item: unknown): item is NumberLiteral {
    return reflection.isInstance(item, NumberLiteral);
}

export interface OutputCubeRef extends langium.AstNode {
    readonly $container: AggregateDefinition | DeriveDefinition | ModelDefinition;
    readonly $type: 'OutputCubeRef';
    cubeRef: langium.Reference<CubeDefinition>;
}

export const OutputCubeRef = 'OutputCubeRef';

export function isOutputCubeRef(item: unknown): item is OutputCubeRef {
    return reflection.isInstance(item, OutputCubeRef);
}

export interface PrimitiveType extends langium.AstNode {
    readonly $container: Component;
    readonly $type: 'PrimitiveType';
    type: 'Date' | 'DateTime' | 'Flag' | 'Integer' | 'Numeric' | 'Text';
}

export const PrimitiveType = 'PrimitiveType';

export function isPrimitiveType(item: unknown): item is PrimitiveType {
    return reflection.isInstance(item, PrimitiveType);
}

export interface Program extends langium.AstNode {
    readonly $type: 'Program';
    elements: Array<ProgramElement>;
}

export const Program = 'Program';

export function isProgram(item: unknown): item is Program {
    return reflection.isInstance(item, Program);
}

export interface RandomEffects extends langium.AstNode {
    readonly $container: ModelDefinition;
    readonly $type: 'RandomEffects';
    structure?: CovarianceStructure;
    subject?: string;
}

export const RandomEffects = 'RandomEffects';

export function isRandomEffects(item: unknown): item is RandomEffects {
    return reflection.isInstance(item, RandomEffects);
}

export interface SliceDefinition extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'SliceDefinition';
    cubeRef: langium.Reference<CubeDefinition>;
    description?: string;
    fixedDimensions?: DimensionConstraints;
    measures?: MeasureList;
    name: string;
    varyingDimensions?: DimensionList;
    whereClause?: Expression;
}

export const SliceDefinition = 'SliceDefinition';

export function isSliceDefinition(item: unknown): item is SliceDefinition {
    return reflection.isInstance(item, SliceDefinition);
}

export interface StandardsDeclaration extends langium.AstNode {
    readonly $container: Program;
    readonly $type: 'StandardsDeclaration';
    standards: Array<StandardVersion>;
}

export const StandardsDeclaration = 'StandardsDeclaration';

export function isStandardsDeclaration(item: unknown): item is StandardsDeclaration {
    return reflection.isInstance(item, StandardsDeclaration);
}

export interface StandardVersion extends langium.AstNode {
    readonly $container: StandardsDeclaration;
    readonly $type: 'StandardVersion';
    standard: string;
    version: string;
}

export const StandardVersion = 'StandardVersion';

export function isStandardVersion(item: unknown): item is StandardVersion {
    return reflection.isInstance(item, StandardVersion);
}

export interface Statistic extends langium.AstNode {
    readonly $container: StatisticList;
    readonly $type: 'Statistic';
    function: AggregateFunction;
    measure: string;
    name: string;
}

export const Statistic = 'Statistic';

export function isStatistic(item: unknown): item is Statistic {
    return reflection.isInstance(item, Statistic);
}

export interface StatisticList extends langium.AstNode {
    readonly $container: AggregateDefinition;
    readonly $type: 'StatisticList';
    statistics: Array<Statistic>;
}

export const StatisticList = 'StatisticList';

export function isStatisticList(item: unknown): item is StatisticList {
    return reflection.isInstance(item, StatisticList);
}

export interface StringLiteral extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'StringLiteral';
    value: string;
}

export const StringLiteral = 'StringLiteral';

export function isStringLiteral(item: unknown): item is StringLiteral {
    return reflection.isInstance(item, StringLiteral);
}

export interface TableSpec extends langium.AstNode {
    readonly $container: DisplayDefinition;
    readonly $type: 'TableSpec';
    columns?: DimensionList;
    format?: FormatSpec;
    rows?: DimensionList;
}

export const TableSpec = 'TableSpec';

export function isTableSpec(item: unknown): item is TableSpec {
    return reflection.isInstance(item, TableSpec);
}

export interface UnaryExpression extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'UnaryExpression';
    operand: Expression;
    operator: '-' | 'not';
}

export const UnaryExpression = 'UnaryExpression';

export function isUnaryExpression(item: unknown): item is UnaryExpression {
    return reflection.isInstance(item, UnaryExpression);
}

export interface VariableReference extends langium.AstNode {
    readonly $container: BinaryExpression | Derivation | DimensionConstraint | FunctionCallExpression | MemberAccessExpression | SliceDefinition | UnaryExpression;
    readonly $type: 'VariableReference';
    variable: string;
}

export const VariableReference = 'VariableReference';

export function isVariableReference(item: unknown): item is VariableReference {
    return reflection.isInstance(item, VariableReference);
}

export type ThunderstruckAstType = {
    AestheticOption: AestheticOption
    AestheticSpec: AestheticSpec
    AggregateDefinition: AggregateDefinition
    BinaryExpression: BinaryExpression
    BooleanLiteral: BooleanLiteral
    CodeListMapping: CodeListMapping
    CodeListMappings: CodeListMappings
    CodeListNamespace: CodeListNamespace
    CodeListRef: CodeListRef
    CodedValueType: CodedValueType
    ColumnFormat: ColumnFormat
    Component: Component
    ComponentList: ComponentList
    ConceptDefinition: ConceptDefinition
    ConceptProperty: ConceptProperty
    ConceptPropertyList: ConceptPropertyList
    CovarianceStructure: CovarianceStructure
    CubeDefinition: CubeDefinition
    CubeStructure: CubeStructure
    Derivation: Derivation
    DerivationList: DerivationList
    DeriveDefinition: DeriveDefinition
    DimensionConstraint: DimensionConstraint
    DimensionConstraints: DimensionConstraints
    DimensionList: DimensionList
    DisplayDefinition: DisplayDefinition
    Expression: Expression
    FigureSpec: FigureSpec
    FootnoteList: FootnoteList
    FormatOption: FormatOption
    FormatSpec: FormatSpec
    Formula: Formula
    FormulaAddition: FormulaAddition
    FormulaConditioning: FormulaConditioning
    FormulaCrossing: FormulaCrossing
    FormulaFunction: FormulaFunction
    FormulaInteraction: FormulaInteraction
    FormulaNesting: FormulaNesting
    FormulaNumber: FormulaNumber
    FormulaPower: FormulaPower
    FormulaTerm: FormulaTerm
    FormulaVariable: FormulaVariable
    FunctionCallExpression: FunctionCallExpression
    IdentifierType: IdentifierType
    ImportPath: ImportPath
    ImportStatement: ImportStatement
    Literal: Literal
    MeasureList: MeasureList
    MemberAccessExpression: MemberAccessExpression
    ModelDefinition: ModelDefinition
    NumberLiteral: NumberLiteral
    OutputCubeRef: OutputCubeRef
    OutputCubeSpec: OutputCubeSpec
    PrimitiveType: PrimitiveType
    Program: Program
    ProgramElement: ProgramElement
    RandomEffects: RandomEffects
    SliceDefinition: SliceDefinition
    StandardVersion: StandardVersion
    StandardsDeclaration: StandardsDeclaration
    Statistic: Statistic
    StatisticList: StatisticList
    StringLiteral: StringLiteral
    TableSpec: TableSpec
    TypeReference: TypeReference
    UnaryExpression: UnaryExpression
    VariableReference: VariableReference
}

export class ThunderstruckAstReflection extends langium.AbstractAstReflection {

    getAllTypes(): string[] {
        return [AestheticOption, AestheticSpec, AggregateDefinition, BinaryExpression, BooleanLiteral, CodeListMapping, CodeListMappings, CodeListNamespace, CodeListRef, CodedValueType, ColumnFormat, Component, ComponentList, ConceptDefinition, ConceptProperty, ConceptPropertyList, CovarianceStructure, CubeDefinition, CubeStructure, Derivation, DerivationList, DeriveDefinition, DimensionConstraint, DimensionConstraints, DimensionList, DisplayDefinition, Expression, FigureSpec, FootnoteList, FormatOption, FormatSpec, Formula, FormulaAddition, FormulaConditioning, FormulaCrossing, FormulaFunction, FormulaInteraction, FormulaNesting, FormulaNumber, FormulaPower, FormulaTerm, FormulaVariable, FunctionCallExpression, IdentifierType, ImportPath, ImportStatement, Literal, MeasureList, MemberAccessExpression, ModelDefinition, NumberLiteral, OutputCubeRef, OutputCubeSpec, PrimitiveType, Program, ProgramElement, RandomEffects, SliceDefinition, StandardVersion, StandardsDeclaration, Statistic, StatisticList, StringLiteral, TableSpec, TypeReference, UnaryExpression, VariableReference];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case AggregateDefinition:
            case ConceptDefinition:
            case DeriveDefinition:
            case DisplayDefinition:
            case ImportStatement:
            case ModelDefinition:
            case SliceDefinition:
            case StandardsDeclaration: {
                return this.isSubtype(ProgramElement, supertype);
            }
            case BinaryExpression:
            case FunctionCallExpression:
            case Literal:
            case MemberAccessExpression:
            case UnaryExpression:
            case VariableReference: {
                return this.isSubtype(Expression, supertype);
            }
            case BooleanLiteral:
            case NumberLiteral:
            case StringLiteral: {
                return this.isSubtype(Literal, supertype);
            }
            case CodedValueType:
            case IdentifierType:
            case PrimitiveType: {
                return this.isSubtype(TypeReference, supertype);
            }
            case CubeDefinition: {
                return this.isSubtype(OutputCubeSpec, supertype) || this.isSubtype(ProgramElement, supertype);
            }
            case FormulaAddition:
            case FormulaConditioning:
            case FormulaCrossing:
            case FormulaFunction:
            case FormulaInteraction:
            case FormulaNesting:
            case FormulaNumber:
            case FormulaPower:
            case FormulaVariable: {
                return this.isSubtype(FormulaTerm, supertype);
            }
            case OutputCubeRef: {
                return this.isSubtype(OutputCubeSpec, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: langium.ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'AggregateDefinition:inputRef':
            case 'DeriveDefinition:inputRef':
            case 'DisplayDefinition:sourceRef':
            case 'ModelDefinition:inputRef': {
                return ProgramElement;
            }
            case 'Component:concept':
            case 'ConceptDefinition:parentType':
            case 'ConceptProperty:type': {
                return ConceptDefinition;
            }
            case 'OutputCubeRef:cubeRef':
            case 'SliceDefinition:cubeRef': {
                return CubeDefinition;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): langium.TypeMetaData {
        switch (type) {
            case AestheticOption: {
                return {
                    name: AestheticOption,
                    properties: [
                        { name: 'key' },
                        { name: 'value' }
                    ]
                };
            }
            case AestheticSpec: {
                return {
                    name: AestheticSpec,
                    properties: [
                        { name: 'options', defaultValue: [] }
                    ]
                };
            }
            case AggregateDefinition: {
                return {
                    name: AggregateDefinition,
                    properties: [
                        { name: 'description' },
                        { name: 'groupBy' },
                        { name: 'inputRef' },
                        { name: 'name' },
                        { name: 'output' },
                        { name: 'statistics' }
                    ]
                };
            }
            case BinaryExpression: {
                return {
                    name: BinaryExpression,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case BooleanLiteral: {
                return {
                    name: BooleanLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case CodedValueType: {
                return {
                    name: CodedValueType,
                    properties: [
                        { name: 'codeList' }
                    ]
                };
            }
            case CodeListMapping: {
                return {
                    name: CodeListMapping,
                    properties: [
                        { name: 'code' },
                        { name: 'namespace' }
                    ]
                };
            }
            case CodeListMappings: {
                return {
                    name: CodeListMappings,
                    properties: [
                        { name: 'mappings', defaultValue: [] }
                    ]
                };
            }
            case CodeListNamespace: {
                return {
                    name: CodeListNamespace,
                    properties: [
                        { name: 'segments', defaultValue: [] }
                    ]
                };
            }
            case CodeListRef: {
                return {
                    name: CodeListRef,
                    properties: [
                        { name: 'segments', defaultValue: [] }
                    ]
                };
            }
            case ColumnFormat: {
                return {
                    name: ColumnFormat,
                    properties: [
                        { name: 'column' },
                        { name: 'options', defaultValue: [] }
                    ]
                };
            }
            case Component: {
                return {
                    name: Component,
                    properties: [
                        { name: 'concept' },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case ComponentList: {
                return {
                    name: ComponentList,
                    properties: [
                        { name: 'components', defaultValue: [] }
                    ]
                };
            }
            case ConceptDefinition: {
                return {
                    name: ConceptDefinition,
                    properties: [
                        { name: 'category' },
                        { name: 'codeLists' },
                        { name: 'definition' },
                        { name: 'description' },
                        { name: 'name' },
                        { name: 'parentType' },
                        { name: 'properties' },
                        { name: 'unit' }
                    ]
                };
            }
            case ConceptProperty: {
                return {
                    name: ConceptProperty,
                    properties: [
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case ConceptPropertyList: {
                return {
                    name: ConceptPropertyList,
                    properties: [
                        { name: 'properties', defaultValue: [] }
                    ]
                };
            }
            case CovarianceStructure: {
                return {
                    name: CovarianceStructure,
                    properties: [
                        { name: 'parameter' },
                        { name: 'structureType' }
                    ]
                };
            }
            case CubeDefinition: {
                return {
                    name: CubeDefinition,
                    properties: [
                        { name: 'description' },
                        { name: 'name' },
                        { name: 'namespace' },
                        { name: 'structure' }
                    ]
                };
            }
            case CubeStructure: {
                return {
                    name: CubeStructure,
                    properties: [
                        { name: 'attributes' },
                        { name: 'dimensions' },
                        { name: 'measures' }
                    ]
                };
            }
            case Derivation: {
                return {
                    name: Derivation,
                    properties: [
                        { name: 'expression' },
                        { name: 'target' }
                    ]
                };
            }
            case DerivationList: {
                return {
                    name: DerivationList,
                    properties: [
                        { name: 'derivations', defaultValue: [] }
                    ]
                };
            }
            case DeriveDefinition: {
                return {
                    name: DeriveDefinition,
                    properties: [
                        { name: 'derivations' },
                        { name: 'description' },
                        { name: 'inputRef' },
                        { name: 'name' },
                        { name: 'output' }
                    ]
                };
            }
            case DimensionConstraint: {
                return {
                    name: DimensionConstraint,
                    properties: [
                        { name: 'dimension' },
                        { name: 'value' }
                    ]
                };
            }
            case DimensionConstraints: {
                return {
                    name: DimensionConstraints,
                    properties: [
                        { name: 'constraints', defaultValue: [] }
                    ]
                };
            }
            case DimensionList: {
                return {
                    name: DimensionList,
                    properties: [
                        { name: 'dimensions', defaultValue: [] }
                    ]
                };
            }
            case DisplayDefinition: {
                return {
                    name: DisplayDefinition,
                    properties: [
                        { name: 'description' },
                        { name: 'displayType' },
                        { name: 'figureSpec' },
                        { name: 'footnotes' },
                        { name: 'sourceRef' },
                        { name: 'tableSpec' },
                        { name: 'title' }
                    ]
                };
            }
            case FigureSpec: {
                return {
                    name: FigureSpec,
                    properties: [
                        { name: 'aesthetics' },
                        { name: 'groupBy' },
                        { name: 'xAxis' },
                        { name: 'yAxis' }
                    ]
                };
            }
            case FootnoteList: {
                return {
                    name: FootnoteList,
                    properties: [
                        { name: 'footnotes', defaultValue: [] }
                    ]
                };
            }
            case FormatOption: {
                return {
                    name: FormatOption,
                    properties: [
                        { name: 'key' },
                        { name: 'value' }
                    ]
                };
            }
            case FormatSpec: {
                return {
                    name: FormatSpec,
                    properties: [
                        { name: 'formats', defaultValue: [] }
                    ]
                };
            }
            case Formula: {
                return {
                    name: Formula,
                    properties: [
                        { name: 'predictors' },
                        { name: 'response' }
                    ]
                };
            }
            case FormulaAddition: {
                return {
                    name: FormulaAddition,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case FormulaConditioning: {
                return {
                    name: FormulaConditioning,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case FormulaCrossing: {
                return {
                    name: FormulaCrossing,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case FormulaFunction: {
                return {
                    name: FormulaFunction,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'function' }
                    ]
                };
            }
            case FormulaInteraction: {
                return {
                    name: FormulaInteraction,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case FormulaNesting: {
                return {
                    name: FormulaNesting,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case FormulaNumber: {
                return {
                    name: FormulaNumber,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case FormulaPower: {
                return {
                    name: FormulaPower,
                    properties: [
                        { name: 'left' },
                        { name: 'operator' },
                        { name: 'right' }
                    ]
                };
            }
            case FormulaVariable: {
                return {
                    name: FormulaVariable,
                    properties: [
                        { name: 'variable' }
                    ]
                };
            }
            case FunctionCallExpression: {
                return {
                    name: FunctionCallExpression,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'function' }
                    ]
                };
            }
            case IdentifierType: {
                return {
                    name: IdentifierType,
                    properties: [
                        { name: 'type' }
                    ]
                };
            }
            case ImportPath: {
                return {
                    name: ImportPath,
                    properties: [
                        { name: 'segments', defaultValue: [] }
                    ]
                };
            }
            case ImportStatement: {
                return {
                    name: ImportStatement,
                    properties: [
                        { name: 'alias' },
                        { name: 'importPath' }
                    ]
                };
            }
            case MeasureList: {
                return {
                    name: MeasureList,
                    properties: [
                        { name: 'measures', defaultValue: [] }
                    ]
                };
            }
            case MemberAccessExpression: {
                return {
                    name: MemberAccessExpression,
                    properties: [
                        { name: 'member' },
                        { name: 'receiver' }
                    ]
                };
            }
            case ModelDefinition: {
                return {
                    name: ModelDefinition,
                    properties: [
                        { name: 'description' },
                        { name: 'family' },
                        { name: 'formula' },
                        { name: 'inputRef' },
                        { name: 'link' },
                        { name: 'name' },
                        { name: 'output' },
                        { name: 'randomEffects' }
                    ]
                };
            }
            case NumberLiteral: {
                return {
                    name: NumberLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case OutputCubeRef: {
                return {
                    name: OutputCubeRef,
                    properties: [
                        { name: 'cubeRef' }
                    ]
                };
            }
            case PrimitiveType: {
                return {
                    name: PrimitiveType,
                    properties: [
                        { name: 'type' }
                    ]
                };
            }
            case Program: {
                return {
                    name: Program,
                    properties: [
                        { name: 'elements', defaultValue: [] }
                    ]
                };
            }
            case RandomEffects: {
                return {
                    name: RandomEffects,
                    properties: [
                        { name: 'structure' },
                        { name: 'subject' }
                    ]
                };
            }
            case SliceDefinition: {
                return {
                    name: SliceDefinition,
                    properties: [
                        { name: 'cubeRef' },
                        { name: 'description' },
                        { name: 'fixedDimensions' },
                        { name: 'measures' },
                        { name: 'name' },
                        { name: 'varyingDimensions' },
                        { name: 'whereClause' }
                    ]
                };
            }
            case StandardsDeclaration: {
                return {
                    name: StandardsDeclaration,
                    properties: [
                        { name: 'standards', defaultValue: [] }
                    ]
                };
            }
            case StandardVersion: {
                return {
                    name: StandardVersion,
                    properties: [
                        { name: 'standard' },
                        { name: 'version' }
                    ]
                };
            }
            case Statistic: {
                return {
                    name: Statistic,
                    properties: [
                        { name: 'function' },
                        { name: 'measure' },
                        { name: 'name' }
                    ]
                };
            }
            case StatisticList: {
                return {
                    name: StatisticList,
                    properties: [
                        { name: 'statistics', defaultValue: [] }
                    ]
                };
            }
            case StringLiteral: {
                return {
                    name: StringLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case TableSpec: {
                return {
                    name: TableSpec,
                    properties: [
                        { name: 'columns' },
                        { name: 'format' },
                        { name: 'rows' }
                    ]
                };
            }
            case UnaryExpression: {
                return {
                    name: UnaryExpression,
                    properties: [
                        { name: 'operand' },
                        { name: 'operator' }
                    ]
                };
            }
            case VariableReference: {
                return {
                    name: VariableReference,
                    properties: [
                        { name: 'variable' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new ThunderstruckAstReflection();
